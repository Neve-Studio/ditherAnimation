<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="Interactive menu dither animation with smooth frame-based transitions">
    <meta name="theme-color" content="#C8C8C8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>Menu Dither Animation</title>
    <link rel="preload" href="menubtn.png" as="image">
    <link rel="preload" href="centerpiece.png" as="image">
    <style>
        /* GT America Font */
        @font-face {
            font-family: 'GT America';
            src: url('GT-America-Condensed-Bold.otf') format('opentype');
            font-weight: bold;
            font-style: normal;
            font-display: swap;
        }

        /* CSS Variables for better maintainability */
        :root {
            --bg-color: #2a2a2a;
            --text-color: #e0e0e0;
            --white: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --button-size: clamp(20px, 4vw, 32px);
            --text-size: clamp(24px, 6vw, 48px);
            --container-padding: clamp(20px, 8vh, 50px);
            --text-margin: clamp(10px, 3vw, 20px);
            --animation-speed: 0.3s;
        }

        /* CSS Reset */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--bg-color);
            overflow: hidden;
            height: 100vh;
            height: 100dvh; /* Modern dynamic viewport height */
            position: relative;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .circular-button {
            width: var(--button-size);
            height: var(--button-size);
            border-radius: 50%;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            z-index: 1001;
            position: relative;
            overflow: hidden;
            transition: transform var(--animation-speed) cubic-bezier(0.4, 0, 0.2, 1);
            mix-blend-mode: difference;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            margin: 0 auto;
            pointer-events: auto;
        }




        .animation-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            pointer-events: none;
            z-index: 100;
            display: none;
            mix-blend-mode: difference;
        }

        .animation-frame {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            object-fit: cover;
            display: none;
            mix-blend-mode: difference;
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .button-text {
            display: none;
        }

        .button-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            user-select: none;
            pointer-events: none;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .state-indicator {
            position: absolute;
            bottom: calc(-1 * var(--button-size) - 5px);
            left: 50%;
            transform: translateX(-50%);
            color: var(--white);
            font-size: clamp(10px, 2vw, 12px);
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
            opacity: 0;
            transition: opacity var(--animation-speed) ease;
            pointer-events: none;
        }

        .state-indicator.visible {
            opacity: 1;
        }

        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: var(--white);
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: clamp(10px, 2vw, 12px);
            z-index: 1001;
            display: none; /* Hidden in production */
            opacity: 0.7;
        }

        .background-text {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 50;
            pointer-events: auto;
            user-select: none;
            display: flex;
            gap: 8vw;
            align-items: center;
            justify-content: center;
            padding: 0 4vw;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .background-text.menu-open {
            pointer-events: auto;
        }

        .menu-column {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 70vh;
            padding: 5vh 0;
            flex: 1;
        }

        .menu-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            position: relative;
        }

        .menu-number {
            font-family: 'GT America', system-ui, sans-serif;
            font-size: clamp(20px, 3vw, 32px);
            color: #00CED1;
            font-weight: bold;
            min-width: 50px;
        }

        .menu-item-image-container {
            position: relative;
            height: clamp(120px, 18vh, 200px);
            width: 100%;
            display: inline-block;
            overflow: hidden;
        }

        .menu-item-image-container img {
            height: clamp(120px, 18vh, 200px);
            width: auto;
            display: block;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            position: absolute;
            top: 0;
            left: 0;
            transition: transform 0.7s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        /* First menu item */
        .menu-item:nth-child(1) .menu-item-image-container img {
            transform: translateY(162%) rotate(5deg);
        }

        /* Second menu item */
        .menu-item:nth-child(2) .menu-item-image-container img {
            transform: translateY(246%) rotate(10deg);
        }

        /* Third menu item */
        .menu-item:nth-child(3) .menu-item-image-container img {
            transform: translateY(254%) rotate(15deg);
        }

        /* Fourth menu item */
        .menu-item:nth-child(4) .menu-item-image-container img {
            transform: translateY(271%) rotate(20deg);
        }

        .menu-item-image-container img.menu-open {
            transform: translateY(0) rotate(0deg) !important;
        }

        .menu-item .hover-image {
            opacity: 0;
            pointer-events: none;
        }

        .menu-item .default-image {
            opacity: 1;
        }

        .menu-item:hover .default-image {
            opacity: 0;
        }

        .menu-item:hover .hover-image {
            opacity: 1;
        }

        /* Hover effects for all menu items when one is hovered */
        .menu-column:hover .menu-item:not(:hover) {
            opacity: 0.8;
            transition: opacity 0.15s ease;
        }

        .menu-column:hover .menu-item:not(:hover) .default-image {
            opacity: 0;
        }

        .menu-column:hover .menu-item:not(:hover) .hover-image {
            opacity: 1;
        }

        /* Hovered item rotation and full visibility */
        .menu-item:hover {
            transform: rotate(-1.49deg);
            transition: transform 0.15s ease, opacity 0.15s ease;
        }



        .descriptions-column {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 70vh;
            padding: 5vh 0;
            align-items: flex-end;
            flex: 0 0 auto;
        }

        .description-item {
            font-family: 'GT America', system-ui, sans-serif;
            font-size: clamp(14px, 2.5vw, 22px);
            color: #C0C0C0;
            text-align: right;
            line-height: 1.4;
            max-width: 280px;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 60;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2vh 4vw;
        }

        .header-left {
            font-family: 'GT America', system-ui, sans-serif;
            font-size: clamp(10px, 1.5vw, 14px);
            color: #C0C0C0;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .header-center {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            pointer-events: auto;
        }

        .header-right {
            font-family: 'GT America', system-ui, sans-serif;
            font-size: clamp(10px, 1.5vw, 14px);
            color: #C0C0C0;
            font-weight: bold;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-arrow {
            width: 12px;
            height: 12px;
            background: #C0C0C0;
            clip-path: polygon(0 100%, 100% 0, 100% 100%);
        }



        .centerpiece {
            position: fixed;
            mix-blend-mode: lighten;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            pointer-events: none;
            opacity: 1;
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .container {
                padding-top: clamp(30px, 10vh, 60px);
            }
            
            .background-text {
                gap: 4vw;
                padding: 0 2vw;
            }
            
            .menu-column {
                height: 65vh;
                padding: 7.5vh 0;
            }
            
            .descriptions-column {
                height: 65vh;
                padding: 7.5vh 0;
            }
            
            .menu-item-image-container {
                height: clamp(60px, 10vh, 100px);
            }
            
            .menu-item img {
                height: clamp(60px, 10vh, 100px);
            }
            
            /* Mobile-specific transforms for menu items */
            .menu-item:nth-child(1) .menu-item-image-container img {
                transform: translateY(162%) rotate(4deg);
            }
            
            .menu-item:nth-child(2) .menu-item-image-container img {
                transform: translateY(170%) rotate(6deg);
            }
            
            .menu-item:nth-child(3) .menu-item-image-container img {
                transform: translateY(178%) rotate(7deg);
            }
            
            .menu-item:nth-child(4) .menu-item-image-container img {
                transform: translateY(187%) rotate(8deg);
            }
            
            .menu-number {
                font-size: clamp(14px, 2vw, 18px);
                margin-right: 2vw;
                min-width: 35px;
            }
            
            .description-item {
                font-size: clamp(10px, 1.8vw, 14px);
                max-width: 160px;
                line-height: 1.3;
            }
            
            .header {
                padding: 1.5vh 2vw;
            }
            
            .header-left,
            .header-right {
                font-size: clamp(8px, 1.2vw, 12px);
            }
            
            .header-center {
                flex: 0.5;
            }
        }

        /* Small mobile devices */
        @media (max-width: 480px) {
            :root {
                --button-size: clamp(24px, 6vw, 28px);
                --text-size: clamp(16px, 4.5vw, 24px);
            }
            
            .background-text {
                gap: 3vw;
                padding: 0 1vw;
            }
            
            .menu-column {
                height: 60vh;
                padding: 10vh 0;
            }
            
            .descriptions-column {
                height: 60vh;
                padding: 10vh 0;
            }
            
            .menu-item-image-container {
                height: clamp(50px, 8vh, 80px);
            }
            
            .menu-item img {
                height: clamp(50px, 8vh, 80px);
            }
            
            /* Small mobile-specific transforms for menu items */
            .menu-item:nth-child(1) .menu-item-image-container img {
                transform: translateY(96%) rotate(4deg);
            }
            
            .menu-item:nth-child(2) .menu-item-image-container img {
                transform: translateY(106%) rotate(6deg);
            }
            
            .menu-item:nth-child(3) .menu-item-image-container img {
                transform: translateY(116%) rotate(7deg);
            }
            
            .menu-item:nth-child(4) .menu-item-image-container img {
                transform: translateY(126%) rotate(8deg);
            }
            
            .menu-number {
                font-size: clamp(12px, 1.8vw, 16px);
                margin-right: 1.5vw;
                min-width: 30px;
            }
            
            .description-item {
                font-size: clamp(9px, 1.5vw, 12px);
                max-width: 120px;
                line-height: 1.2;
            }
            
            .header {
                padding: 1vh 1.5vw;
            }
            
            .header-center {
                flex: 0.5;
            }
            
            .header-arrow {
                width: 10px;
                height: 10px;
            }
        }

        /* Landscape mobile optimization */
        @media (orientation: landscape) and (max-height: 500px) {
            .container {
                padding-top: 20px;
            }
            
            .background-text {
                font-size: clamp(14px, 3vw, 24px);
                bottom: 10px;
                left: 10px;
            }
            
            :root {
                --button-size: clamp(18px, 3.5vw, 24px);
            }
        }

        /* Tablet styles */
        @media (min-width: 769px) and (max-width: 1024px) {
            :root {
                --button-size: clamp(28px, 3vw, 40px);
                --text-size: clamp(32px, 4vw, 52px);
            }
        }

        /* High DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .button-image,
            .centerpiece,
            .animation-frame {
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
            }
        }

        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            .circular-button,
            .state-indicator {
                transition: none;
            }
        }



        /* Print styles */
        @media print {
            .circular-button,
            .state-indicator,
            .debug-info,
            .animation-container {
                display: none !important;
            }
            
            .background-text {
                color: #000000 !important;
                text-shadow: none;
            }
        }

        /* Loading state */
        .loading .circular-button {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .loading .fps-toggle {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Loading indicator */
        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: var(--white);
            padding: 20px 30px;
            border-radius: 10px;
            font-family: system-ui, sans-serif;
            font-size: clamp(14px, 3vw, 18px);
            font-weight: bold;
            text-align: center;
            z-index: 2000;
            display: none;
            backdrop-filter: blur(10px);
            border: 2px solid var(--white);
        }

        .loading .loading-indicator {
            display: block;
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: var(--white);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        /* Focus and accessibility improvements */
        .circular-button:focus {
            outline: none;
        }

        .circular-button:focus-visible {
            outline: 2px solid var(--white);
            outline-offset: 2px;
        }

        .menu-item:focus {
            outline: none;
        }

        .menu-item:focus-visible {
            outline: 2px solid var(--white);
            outline-offset: 4px;
            border-radius: 4px;
        }



        /* Performance optimizations */
        .animation-frame,
        .centerpiece,
        .circular-button {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        /* FPS Toggle Control */
        .fps-toggle {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: var(--white);
            border: 2px solid var(--white);
            border-radius: 20px;
            padding: 8px 16px;
            font-family: system-ui, sans-serif;
            font-size: clamp(12px, 2.5vw, 14px);
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .fps-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .fps-toggle:active {
            transform: scale(0.95);
        }

        .fps-toggle:focus-visible {
            outline: 2px solid var(--white);
            outline-offset: 2px;
        }

        .fps-toggle.fps-60 {
            background: rgba(0, 150, 0, 0.8);
            border-color: #00ff00;
        }

        .fps-toggle.fps-30 {
            background: rgba(150, 150, 0, 0.8);
            border-color: #ffff00;
        }

    </style>
</head>
<body>


    <header class="header">
        <div class="header-left">GRACE BRIGADE</div>
        <div class="header-center">
            <button 
                class="circular-button" 
                id="triggerButton"
                aria-label="Toggle menu animation"
                type="button"
            >
                <img 
                    src="menubtn.png" 
                    alt="Menu Button" 
                    class="button-image"
                    loading="eager"
                    decoding="async"
                >
                <div class="button-text">MENU</div>
                <div class="state-indicator" aria-live="polite" aria-atomic="true">Ready</div>
            </button>
        </div>
        <div class="header-right">
            FOR A TOUCH OF GRACE
            <div class="header-arrow"></div>
        </div>
    </header>

    <main class="container" role="main">
    </main>

    <img 
        src="centerpiece.png" 
        alt="Decorative centerpiece" 
        class="centerpiece" 
        id="centerpiece"
        loading="eager"
        decoding="async"
    >

    <div class="background-text" id="backgroundText">
        <div class="menu-column">
            <div class="menu-item" data-menu="welcome">
                <span class="menu-number">01</span>
                <div class="menu-item-image-container">
                    <img src="menu/menu-welcome - 4x.png" alt="Welcome" class="default-image" loading="lazy">
                    <img src="menu/menu-welcome-hover - 4x.png" alt="Welcome Hover" class="hover-image" loading="lazy">
                </div>
            </div>
            <div class="menu-item" data-menu="testkitchen">
                <span class="menu-number">02</span>
                <div class="menu-item-image-container">
                    <img src="menu/menu-testkitchen - 4x.png" alt="Test Kitchen" class="default-image" loading="lazy">
                    <img src="menu/menu-testkitchen-hover - 4x.png" alt="Test Kitchen Hover" class="hover-image" loading="lazy">
                </div>
            </div>
            <div class="menu-item" data-menu="usermanual">
                <span class="menu-number">03</span>
                <div class="menu-item-image-container">
                    <img src="menu/menu-usermanual - 4x.png" alt="User Manual" class="default-image" loading="lazy">
                    <img src="menu/menu-usermanual-hover - 4x.png" alt="User Manual Hover" class="hover-image" loading="lazy">
                </div>
            </div>
            <div class="menu-item" data-menu="contact">
                <span class="menu-number">04</span>
                <div class="menu-item-image-container">
                    <img src="menu/menu-contact - 4x.png" alt="Contact" class="default-image" loading="lazy">
                    <img src="menu/menu-contact-hover - 4x.png" alt="Contact Hover" class="hover-image" loading="lazy">
                </div>
            </div>
        </div>
        
        <!-- <div class="descriptions-column">
            <div class="description-item">ABOUT GRACE BRIGADE</div>
            <div class="description-item">THOUGHTS AND EXPERIMENTS</div>
            <div class="description-item">OUR PHILOSOPHY</div>
            <div class="description-item">GET IN TOUCH</div>
        </div> -->
    </div>

    <div class="animation-container" id="animationContainer" aria-hidden="true">
        <!-- Animation frames will be dynamically added here -->
    </div>

    <button 
        class="fps-toggle fps-60" 
        id="fpsToggle"
        aria-label="Toggle frame rate between 30fps and 60fps"
        type="button"
        style="display: none;"
    >
        60 FPS
    </button>

    <div class="loading-indicator" id="loadingIndicator">
        <div>Loading Animation Frames...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgressBar"></div>
        </div>
        <div id="loadingText">0%</div>
    </div>

    <div class="debug-info" id="debugInfo" aria-hidden="true">
        Ready to animate
    </div>

    <script>
        class MenuAnimation {
            constructor() {
                // Configuration
                this.config = {
                    currentFPS: 60, // Default to 60fps
                    fps30: {
                        totalFrames: 30,
                        frameDuration: 33.33, // ~30fps (1000ms/30)
                        frameOffset: 72,
                        folders: {
                            opening: 'jpg-in',
                            closing: 'jpg-out'
                        }
                    },
                    fps60: {
                        totalFrames: 75, // 60fps folders have 75 frames (00000-00074)
                        frameDuration: 20.83, // ~60fps at 0.8x speed (1000ms/48fps)
                        frameOffset: 180, // Closing frames start from 180
                        folders: {
                            opening: 'jpg-in60',  // Use 60fps folders
                            closing: 'jpg-out60'  // Use 60fps folders
                        }
                    }
                };

                // DOM elements
                this.elements = {
                    button: document.getElementById('triggerButton'),
                    container: document.getElementById('animationContainer'),
                    debugInfo: document.getElementById('debugInfo'),
                    centerpiece: document.getElementById('centerpiece'),
                    backgroundText: document.getElementById('backgroundText'),
                    fpsToggle: document.getElementById('fpsToggle'),
                    loadingIndicator: document.getElementById('loadingIndicator'),
                    loadingProgressBar: document.getElementById('loadingProgressBar'),
                    loadingText: document.getElementById('loadingText')
                };

                // Animation state
                this.state = {
                    frames30: [],
                    outFrames30: [],
                    frames60: [],
                    outFrames60: [],
                    currentFrame: 0,
                    isPlaying: false,
                    isExpanded: false,
                    loadedFrames: 0,
                    animationId: null,
                    menuTriggered: false,
                    framesLoaded: {
                        fps30: false,
                        fps60: false
                    }
                };
                
                this.init();
            }

            init() {
                try {
                    this.setupEventListeners();
                    this.preloadFrames();
                    this.updateDebug('Initializing 60fps mode...');
                    this.updateStateIndicator('Ready');
                    
                    // Add loading state
                    document.body.classList.add('loading');
                } catch (error) {
                    console.error('MenuAnimation initialization failed:', error);
                    this.updateDebug('Initialization failed');
                }
            }

            setupEventListeners() {
                // Button interaction
                this.elements.button.addEventListener('click', () => this.handleButtonClick());
                this.elements.button.addEventListener('keydown', (e) => this.handleKeydown(e));
                
                // FPS toggle
                this.elements.fpsToggle.addEventListener('click', () => this.handleFpsToggle());
                this.elements.fpsToggle.addEventListener('keydown', (e) => this.handleFpsToggleKeydown(e));
                
                // Performance optimizations
                document.addEventListener('visibilitychange', () => this.handleVisibilityChange());
                window.addEventListener('resize', this.debounce(() => this.handleResize(), 250));
                
                // Touch events for mobile
                this.elements.button.addEventListener('touchstart', () => this.handleTouchStart(), { passive: true });
            }

            handleKeydown(event) {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    this.handleButtonClick();
                }
            }

            handleFpsToggleKeydown(event) {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    this.handleFpsToggle();
                }
            }

            handleTouchStart() {
                // Prevent 300ms delay on mobile
                this.elements.button.classList.add('touched');
            }

            handleButtonClick() {
                if (this.state.isPlaying) return;
                
                if (this.state.isExpanded) {
                    this.startClosingAnimation();
                } else {
                    this.startOpeningAnimation();
                }
            }

            handleFpsToggle() {
                if (this.state.isPlaying) {
                    this.updateDebug('Cannot change FPS during animation');
                    return;
                }

                // Complete reset of animation state
                this.resetAnimationState();

                // Change FPS mode
                this.config.currentFPS = this.config.currentFPS === 30 ? 60 : 30;
                this.updateFpsToggleUI();
                this.updateDebug(`Switched to ${this.config.currentFPS}fps mode`);
                
                // Load frames for new FPS if not already loaded
                if (!this.state.framesLoaded[`fps${this.config.currentFPS}`]) {
                    this.preloadFramesForCurrentFPS();
                } else {
                    // Frames already loaded, just remove loading state
                    document.body.classList.remove('loading');
                }
            }

            updateFpsToggleUI() {
                const toggle = this.elements.fpsToggle;
                toggle.textContent = `${this.config.currentFPS} FPS`;
                toggle.className = `fps-toggle fps-${this.config.currentFPS}`;
            }

            handleVisibilityChange() {
                if (document.hidden && this.state.isPlaying) {
                    // Pause animation when tab is not visible
                    if (this.state.animationId) {
                        clearTimeout(this.state.animationId);
                    }
                }
            }

            handleResize() {
                // Recalculate positions on resize
                if (this.state.isPlaying) {
                    // Update frame positions if needed
                    this.updateFramePositions();
                }
            }

            updateDebug(message) {
                if (this.elements.debugInfo) {
                    this.elements.debugInfo.textContent = message;
                }
                console.log(`MenuAnimation: ${message}`);
            }

            preloadFrames() {
                this.updateDebug('Preloading 60fps frames...');
                this.preloadFramesForCurrentFPS();
            }

            preloadFramesForCurrentFPS() {
                const fpsConfig = this.getCurrentFPSConfig();
                const fpsKey = `fps${this.config.currentFPS}`;
                
                if (this.state.framesLoaded[fpsKey]) {
                    this.updateDebug(`${this.config.currentFPS}fps frames already loaded`);
                    document.body.classList.remove('loading');
                    return;
                }

                // Special case: if 60fps uses same folders as 30fps and 30fps is already loaded
                if (this.config.currentFPS === 60 && this.state.framesLoaded['fps30']) {
                    // Copy references from 30fps arrays to 60fps arrays (same images, different playback speed)
                    this.state.frames60 = [...this.state.frames30];
                    this.state.outFrames60 = [...this.state.outFrames30];
                    this.state.framesLoaded['fps60'] = true;
                    this.updateDebug('60fps frames loaded (reusing 30fps frames)');
                    document.body.classList.remove('loading');
                    return;
                }

                // Special case: if 30fps wants to load but 60fps is already loaded (reuse)
                if (this.config.currentFPS === 30 && this.state.framesLoaded['fps60']) {
                    // Copy references from 60fps arrays to 30fps arrays
                    this.state.frames30 = [...this.state.frames60];
                    this.state.outFrames30 = [...this.state.outFrames60];
                    this.state.framesLoaded['fps30'] = true;
                    this.updateDebug('30fps frames loaded (reusing 60fps frames)');
                    document.body.classList.remove('loading');
                    return;
                }

                this.updateDebug(`Preloading ${this.config.currentFPS}fps frames...`);
                
                // Add loading state when loading new FPS
                document.body.classList.add('loading');
                
                // Clear previous frame counts for this FPS
                this.state.loadedFrames = 0;
                
                // Determine target arrays
                const framesArray = this.config.currentFPS === 30 ? this.state.frames30 : this.state.frames60;
                const outFramesArray = this.config.currentFPS === 30 ? this.state.outFrames30 : this.state.outFrames60;
                
                // Only clear arrays if they're truly empty or from different sources
                if (framesArray.length === 0) {
                    // Preload opening frames
                    this.preloadFrameSet('opening', 0, fpsConfig.totalFrames, framesArray, fpsConfig);
                    
                    // Preload closing frames
                    this.preloadFrameSet('closing', fpsConfig.frameOffset, fpsConfig.totalFrames, outFramesArray, fpsConfig);
                } else {
                    // Frames already exist, mark as loaded
                    this.state.framesLoaded[fpsKey] = true;
                    this.updateDebug(`${this.config.currentFPS}fps frames already available`);
                    document.body.classList.remove('loading');
                }
            }

            getCurrentFPSConfig() {
                return this.config[`fps${this.config.currentFPS}`];
            }

            preloadFrameSet(type, startOffset, count, targetArray, fpsConfig) {
                const folder = fpsConfig.folders[type];
                const is60fps = this.config.currentFPS === 60;
                
                for (let i = 0; i < count; i++) {
                    const frameNumber = (i + startOffset).toString().padStart(5, '0');
                    const img = new Image();
                    
                    // Add frame info for tracking
                    img.dataset.frameIndex = i;
                    img.dataset.frameType = type;
                    img.dataset.fps = this.config.currentFPS;
                    
                    img.onload = () => {
                        this.updateDebug(`Frame loaded: ${type} ${frameNumber} for ${this.config.currentFPS}fps`);
                        this.handleFrameLoad();
                    };
                    
                    img.onerror = () => {
                        this.updateDebug(`Frame error: ${type} ${frameNumber} for ${this.config.currentFPS}fps`);
                        this.handleFrameError(frameNumber, folder);
                    };
                    
                    // Handle different naming convention for 60fps folders
                    let framePath;
                    if (is60fps) {
                        framePath = `${folder}/menu-mask 60_${frameNumber}.jpg`;
                    } else {
                        framePath = `${folder}/menu-mask_${frameNumber}.jpg`;
                    }
                    
                    img.src = framePath;
                    img.className = 'animation-frame';
                    img.style.display = 'none';
                    img.loading = 'eager';
                    img.decoding = 'sync'; // Force synchronous decoding
                    
                    targetArray.push(img);
                    this.elements.container.appendChild(img);
                }
            }

            handleFrameLoad() {
                this.state.loadedFrames++;
                const fpsConfig = this.getCurrentFPSConfig();
                const totalFrames = fpsConfig.totalFrames * 2;
                const progress = Math.round((this.state.loadedFrames / totalFrames) * 100);
                
                // Update visual progress indicator
                this.updateLoadingProgress(progress, `Loading ${this.config.currentFPS}fps frames...`);
                
                this.updateDebug(`Loading ${this.config.currentFPS}fps frames... ${this.state.loadedFrames}/${totalFrames} (${progress}%)`);
                
                if (this.state.loadedFrames === totalFrames) {
                    // Wait a bit to ensure all frames are fully processed
                    setTimeout(() => {
                        this.validateAndCompleteLoading();
                    }, 100);
                }
            }

            updateLoadingProgress(percentage, message) {
                if (this.elements.loadingProgressBar) {
                    this.elements.loadingProgressBar.style.width = `${percentage}%`;
                }
                if (this.elements.loadingText) {
                    this.elements.loadingText.textContent = `${percentage}%`;
                }
                if (message && this.elements.loadingIndicator) {
                    const messageDiv = this.elements.loadingIndicator.querySelector('div:first-child');
                    if (messageDiv) {
                        messageDiv.textContent = message;
                    }
                }
            }

            validateAndCompleteLoading() {
                const fpsConfig = this.getCurrentFPSConfig();
                const framesArray = this.config.currentFPS === 30 ? this.state.frames30 : this.state.frames60;
                const outFramesArray = this.config.currentFPS === 30 ? this.state.outFrames30 : this.state.outFrames60;
                
                // Validate all frames are actually loaded
                const allFrames = [...framesArray, ...outFramesArray];
                let validFrames = 0;
                
                allFrames.forEach((frame, index) => {
                    if (frame && frame.complete && frame.naturalWidth > 0) {
                        validFrames++;
                    } else {
                        this.updateDebug(`Frame ${index} not ready: complete=${frame?.complete}, width=${frame?.naturalWidth}`);
                    }
                });
                
                this.updateDebug(`Validation: ${validFrames}/${allFrames.length} frames are ready`);
                
                if (validFrames === allFrames.length) {
                    this.state.framesLoaded[`fps${this.config.currentFPS}`] = true;
                    this.updateDebug(`✅ ALL ${this.config.currentFPS}fps frames loaded and validated! Animation ready.`);
                    
                    // Show completion message
                    this.updateLoadingProgress(100, `${this.config.currentFPS}fps frames ready!`);
                    
                    // Remove loading state after a brief delay to show completion
                    setTimeout(() => {
                        document.body.classList.remove('loading');
                    }, 500);
                } else {
                    // Try again after a short delay
                    this.updateDebug(`⏳ Waiting for remaining frames to load...`);
                    this.updateLoadingProgress(95, 'Finalizing frames...');
                    setTimeout(() => {
                        this.validateAndCompleteLoading();
                    }, 200);
                }
            }

            handleFrameError(frameNumber, folder) {
                const is60fps = this.config.currentFPS === 60;
                let framePath;
                if (is60fps) {
                    framePath = `${folder}/menu-mask 60_${frameNumber}.jpg`;
                } else {
                    framePath = `${folder}/menu-mask_${frameNumber}.jpg`;
                }
                console.error(`Failed to load: ${framePath}`);
                this.updateDebug(`Error loading frame ${frameNumber}`);
            }

            startOpeningAnimation() {
                const fpsKey = `fps${this.config.currentFPS}`;
                if (!this.state.framesLoaded[fpsKey]) {
                    this.updateDebug('Still loading frames...');
                    return;
                }
                
                // Ensure we have valid frames
                const currentFrames = this.config.currentFPS === 30 ? this.state.frames30 : this.state.frames60;
                this.updateDebug(`Frame arrays: 30fps=${this.state.frames30.length}, 60fps=${this.state.frames60.length}, current=${currentFrames.length}`);
                
                if (!currentFrames || currentFrames.length === 0) {
                    this.updateDebug(`No frames available for ${this.config.currentFPS}fps - trying to load`);
                    this.preloadFramesForCurrentFPS();
                    return;
                }
                
                this.updateDebug(`Starting ${this.config.currentFPS}fps opening animation...`);
                
                // Reset animation state but set playing AFTER reset
                this.resetAnimationState();
                this.state.isPlaying = true;
                this.state.currentFrame = 0;
                this.state.menuTriggered = false;
                
                // Show container FIRST
                this.elements.container.style.display = 'block';
                
                // Double-check all frames are hidden
                this.hideAllFrames();
                
                // Use double RAF to ensure everything is rendered
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        this.playNextFrame(currentFrames, true);
                    });
                });
            }

            startClosingAnimation() {
                // Ensure we have valid frames
                const currentClosingFrames = this.config.currentFPS === 30 ? this.state.outFrames30 : this.state.outFrames60;
                if (!currentClosingFrames || currentClosingFrames.length === 0) {
                    this.updateDebug('No closing frames available for current FPS');
                    return;
                }
                
                this.updateDebug(`Starting ${this.config.currentFPS}fps closing animation...`);
                this.state.isPlaying = true;
                this.state.currentFrame = 0;
                
                // Hide menu items immediately when closing starts
                this.state.isExpanded = false;
                this.toggleMenuVisibility();
                this.updateDebug('Menu items hidden immediately on close');
                
                // Get current FPS closing frames and hide others
                this.hideAllFramesExcept(currentClosingFrames);
                
                this.playNextFrame(currentClosingFrames, false);
            }

            playNextFrame(frameArray, isOpening) {
                // Safety check: ensure we're still supposed to be playing
                if (!this.state.isPlaying) {
                    return;
                }
                
                if (this.state.currentFrame >= frameArray.length) {
                    this.endAnimation(isOpening);
                    return;
                }

                const currentFrame = frameArray[this.state.currentFrame];
                
                // Validate frame exists
                if (!currentFrame) {
                    this.updateDebug(`Frame ${this.state.currentFrame} not found, ending animation`);
                    this.endAnimation(isOpening);
                    return;
                }
                
                // More lenient validation - just check if it's an image element
                if (!currentFrame.src) {
                    this.updateDebug(`Frame ${this.state.currentFrame} has no source, ending animation`);
                    this.endAnimation(isOpening);
                    return;
                }
                
                // Hide previous frame FIRST
                if (this.state.currentFrame > 0) {
                    const previousFrame = frameArray[this.state.currentFrame - 1];
                    if (previousFrame && previousFrame.style) {
                        previousFrame.style.display = 'none';
                    }
                }
                
                // Position and show current frame
                this.positionFrame(currentFrame);
                currentFrame.style.display = 'block';
                
                const action = isOpening ? 'Opening' : 'Closing';
                this.updateDebug(`${action} Frame ${this.state.currentFrame + 1}/${frameArray.length}`);
                
                // Trigger menu visibility early during opening animation (at 25% completion)
                if (isOpening && this.state.currentFrame >= Math.floor(frameArray.length * 0.25) && !this.state.menuTriggered) {
                    this.state.menuTriggered = true;
                    this.state.isExpanded = true;
                    this.toggleMenuVisibility();
                    this.updateDebug('Menu items triggered early during animation');
                }
                
                this.state.currentFrame++;
                
                // Use current FPS configuration for timing
                const fpsConfig = this.getCurrentFPSConfig();
                
                // Schedule next frame only if still playing
                this.state.animationId = setTimeout(() => {
                    if (!document.hidden && this.state.isPlaying) {
                        this.playNextFrame(frameArray, isOpening);
                    }
                }, fpsConfig.frameDuration);
            }

            positionFrame(frame) {
                // Position frames at the center of the circular button
                const buttonRect = this.elements.button.getBoundingClientRect();
                const buttonCenterX = buttonRect.left + buttonRect.width / 2;
                const buttonCenterY = buttonRect.top + buttonRect.height / 2;
                
                frame.style.left = buttonCenterX + 'px';
                frame.style.top = buttonCenterY + 'px';
                frame.style.transform = 'translate(-50%, -50%)';
                frame.style.width = 'auto';
                frame.style.height = 'auto';
                frame.style.objectFit = 'contain';
            }

            hideAllFrames() {
                // Hide all frames from all FPS modes to prevent flashing/interference
                const allFrames = [
                    ...this.state.frames30, 
                    ...this.state.outFrames30, 
                    ...this.state.frames60, 
                    ...this.state.outFrames60
                ];
                
                allFrames.forEach(frame => {
                    if (frame && frame.style) {
                        frame.style.display = 'none';
                    }
                });
                
                // Reset current frame counter
                this.state.currentFrame = 0;
            }

            resetAnimationState() {
                // Clear any existing timeouts
                if (this.state.animationId) {
                    clearTimeout(this.state.animationId);
                    this.state.animationId = null;
                }
                
                // Reset frame counter (don't touch isPlaying here)
                this.state.currentFrame = 0;
                
                // Hide all frames completely
                this.hideAllFrames();
            }

            hideAllFramesExcept(framesToKeep) {
                // Hide all frames except the ones we want to keep visible
                const allFrames = [
                    ...this.state.frames30, 
                    ...this.state.outFrames30, 
                    ...this.state.frames60, 
                    ...this.state.outFrames60
                ];
                
                allFrames.forEach(frame => {
                    if (frame && frame.style) {
                        if (!framesToKeep.includes(frame)) {
                            frame.style.display = 'none';
                        }
                    }
                });
                
                // Reset current frame counter
                this.state.currentFrame = 0;
            }

            updateFramePositions() {
                // Update positions of visible frames during resize
                const allFrames = [...this.state.frames30, ...this.state.outFrames30, ...this.state.frames60, ...this.state.outFrames60];
                const visibleFrames = allFrames.filter(frame => frame.style.display === 'block');
                
                visibleFrames.forEach(frame => this.positionFrame(frame));
            }

            endAnimation(isOpening) {
                if (isOpening) {
                    this.updateDebug('Opening complete');
                    this.state.isExpanded = true;
                    this.elements.button.classList.add('expanded');
                    this.updateStateIndicator('Expanded');
                    
                    // Don't call toggleMenuVisibility here if we already triggered it early
                    if (!this.state.menuTriggered) {
                        this.toggleMenuVisibility();
                    }
                } else {
                    this.updateDebug('Closing complete');
                    this.state.isExpanded = false;
                    this.elements.button.classList.remove('expanded');
                    this.updateStateIndicator('Collapsed');
                    
                    // Hide container when closing animation ends
                    this.elements.container.style.display = 'none';
                    
                    // Don't call toggleMenuVisibility here - already called at start of closing
                }
                
                this.state.isPlaying = false;
                if (this.state.animationId) {
                    clearTimeout(this.state.animationId);
                    this.state.animationId = null;
                }
            }

            updateStateIndicator(text) {
                const indicator = this.elements.button.querySelector('.state-indicator');
                if (indicator) {
                    indicator.textContent = text;
                    indicator.classList.add('visible');
                    
                    setTimeout(() => {
                        indicator.classList.remove('visible');
                    }, 2000);
                }
            }

            toggleMenuVisibility() {
                const backgroundTexts = document.querySelectorAll('.menu-item-image-container img');
                console.log(backgroundTexts);
                const backgroundTextsContainer = document.getElementById('backgroundText');
                let wait = 0;
                if (backgroundTexts) {
                    if (this.state.isExpanded) {
                        backgroundTextsContainer.classList.add('menu-open');
                        backgroundTexts.forEach(text => {
                            setTimeout(() => {
                                text.classList.add('menu-open');
                            }, wait);
                            wait += 5; // Ridotto da 20ms a 5ms per animazione più veloce
                        });
                    } else {
                        backgroundTextsContainer.classList.remove('menu-open');
                        backgroundTexts.forEach(text => {
                            setTimeout(() => {
                                text.classList.remove('menu-open');
                            }, wait);
                            wait += 5; // Ridotto da 20ms a 5ms per animazione più veloce
                        });
                    }
                }
            }

            // Utility function for debouncing
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func.apply(this, args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }

        // Menu interaction functionality
        class MenuInteraction {
            constructor() {
                this.setupMenuItemEvents();
            }

            setupMenuItemEvents() {
                const menuItems = document.querySelectorAll('.menu-item');
                const descriptions = document.querySelectorAll('.description-item');
                
                menuItems.forEach((item, index) => {
                    item.addEventListener('click', (e) => {
                        const menuType = item.dataset.menu;
                        this.handleMenuClick(menuType);
                    });
                    
                    item.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            const menuType = item.dataset.menu;
                            this.handleMenuClick(menuType);
                        }
                    });
                    
                    // Hover effects
                    item.addEventListener('mouseenter', () => {
                        this.handleMenuHover(index, true);
                    });
                    
                    item.addEventListener('mouseleave', () => {
                        this.handleMenuHover(index, false);
                    });
                    
                    // Make menu items focusable for accessibility
                    item.setAttribute('tabindex', '0');
                    item.setAttribute('role', 'button');
                });
            }

            handleMenuHover(hoveredIndex, isHovering) {
                const menuItems = document.querySelectorAll('.menu-item');
                const descriptions = document.querySelectorAll('.description-item');
                const backgroundText = document.getElementById('backgroundText');
                
                // Only handle hover if menu is open
                if (!backgroundText || !backgroundText.classList.contains('menu-open')) {
                    return;
                }
                
                if (isHovering) {
                    // Fade out all other menu items and show their hover images
                    menuItems.forEach((item, index) => {
                        if (index !== hoveredIndex) {
                            item.style.opacity = '0.8';
                            const defaultImg = item.querySelector('.default-image');
                            const hoverImg = item.querySelector('.hover-image');
                            if (defaultImg) defaultImg.style.opacity = '0';
                            if (hoverImg) hoverImg.style.opacity = '1';
                        }
                    });
                    
                    // Fade out all descriptions
                    descriptions.forEach(desc => {
                        desc.style.opacity = '0.8';
                    });
                    
                    // Keep hovered item and its description fully visible
                    const hoveredItem = menuItems[hoveredIndex];
                    const hoveredDesc = descriptions[hoveredIndex];
                    if (hoveredItem) hoveredItem.style.opacity = '1';
                    if (hoveredDesc) hoveredDesc.style.opacity = '1';
                } else {
                    // Reset all items to normal state
                    menuItems.forEach(item => {
                        item.style.opacity = '1';
                        const defaultImg = item.querySelector('.default-image');
                        const hoverImg = item.querySelector('.hover-image');
                        if (defaultImg) defaultImg.style.opacity = '1';
                        if (hoverImg) hoverImg.style.opacity = '0';
                    });
                    
                    descriptions.forEach(desc => {
                        desc.style.opacity = '1';
                    });
                }
            }

            handleMenuClick(menuType) {
                console.log(`Menu clicked: ${menuType}`);
                
                // Add your menu navigation logic here
                switch(menuType) {
                    case 'welcome':
                        console.log('Navigate to Welcome page');
                        // window.location.href = '/welcome';
                        break;
                    case 'testkitchen':
                        console.log('Navigate to Test Kitchen page');
                        // window.location.href = '/test-kitchen';
                        break;
                    case 'usermanual':
                        console.log('Navigate to User Manual page');
                        // window.location.href = '/user-manual';
                        break;
                    case 'contact':
                        console.log('Navigate to Contact page');
                        // window.location.href = '/contact';
                        break;
                    default:
                        console.log('Unknown menu item');
                }
            }
        }

        // Initialize both animation and menu interaction when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new MenuAnimation();
            new MenuInteraction();
        });
    </script>
</body>
</html> 